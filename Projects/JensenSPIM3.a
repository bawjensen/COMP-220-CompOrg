# Bryan Jensen
# April 12, 2014
#
# Description:  
#
# Input:        
#
# Output:       



# Stack Set-Up:
#       sp      fp      use             typically
#       --      --      ---             ---------
# sp -> 0       -28     empty
#       4       -24     empty
#       8       -20     fp              $fp
#       12      -16     ra              $ra
#       16      -12     local0          $a0
#       20      -8      local1
#       24      -4      local2
# fp -> 28      -0      local3

# Caller's stack:
# oldsp 32       4

        .data
prompt: .asciiz "Enter how far in the fibonacci sequence to go: "
# Array of length 45, filled with sentinel value
sum:    .asciiz "The sum of the fibonacci numbers is "
fin:    .asciiz "\n\nFinished, terminating."
endl:   .asciiz "\n"

        .text
        .globl main
main:
        li      $v0, 4                  # 4 - Print string
        la      $a0, prompt             # Load in the "Enter a value" prompt
        syscall                         # Print out the prompt

        li      $v0, 5                  # 5 - Read integer
        syscall                         # Read in the integer, n, for how many fibonacci numbers
        move    $a0, $v0                # Move the input number as the first argument to 'fib' procedure call

        jal     fib                     # Call 'fib' procedure

        move    $t0, $v0                # Move the answer (sum of n fibonacci numbers) to $t0

        li      $v0, 4                  # 4 - Print string
        la      $a0, sum                # Load in the "Sum is: " string
        syscall                         # Print out the sum label

        li      $v0, 1                  # 1 - Print integer
        move    $a0, $t0                # Load in the nth fibonacci number
        syscall                         # Print out the answer

done:
        li      $v0, 4                  # 4 - Print string
        la      $a0, fin                # Load goodbye prompt
        syscall                         # Print out prompt
        
        li      $v0, 10                 # 10 - Exit
        syscall                         # Exit the system

# -------------------------------------------------------------------- #

# Procedure: fibRecur

# Purpose:
# Parameters:
# Returns:

        .data

        .text
fibRecur:
        subu    $sp, $sp, 32            # Shift stack pointer to new location
        sw      $ra, 12($sp)            # Save the old return address
        sw      $fp, 8($sp)             # Save the old frame pointer
        addu    $fp, $sp, 28            # Set frame pointer to new location relative to stack pointer

        li      $t0, 0
        beq     $a0, $t0, zero

        li      $t0, 1
        beq     $a0, $t0, one

        sw      $a0, -12($fp)           # Store the first argument
        subu    $a0, $a0, 1             # Create first new argument (n-1)
        jal     fibRecur                # F(n-1) - Arguments go in as $a0, answer comes back in $v0 and $v1

        move    $t0, $v1
        add     $v1, $v0, $v1
        move    $v0, $t0
        j       fibRecur_done

zero:
        li      $v0, 0
        j       fibRecur_done

one:
        li      $v0, 0
        li      $v1, 1
        j       fibRecur_done

fibRecur_done:
        lw      $ra, 12($sp)            # Restore old return address value
        lw      $fp, 8($sp)             # Restore old frame pointer
        addu    $sp, $sp, 32            # Shift stack pointer back to old location

        j       $ra                     # Return to caller

# -------------------------------------------------------------------- #

# Procedure: fib

# Purpose:
# Parameters:
# Returns:

        .data

        .text
fib:
        subu    $sp, $sp, 32            # Shift stack pointer to new location
        sw      $ra, 12($sp)            # Save the old return address
        sw      $fp, 8($sp)             # Save the old frame pointer
        addu    $fp, $sp, 28            # Set frame pointer to new location relative to stack pointer

        sw      $a0, -12($fp)           # Store the first argument

        jal     fibRecur                # F(n) - Arguments go in as $a0, answer comes back in $v0 and $v1
        move    $v0, $v1

        lw      $a0, -12($fp)           # Load the first argument back

fib_done:
        lw      $ra, 12($sp)            # Restore old return address value
        lw      $fp, 8($sp)             # Restore old frame pointer
        addu    $sp, $sp, 32            # Shift stack pointer back to old location

        j       $ra                     # Return to caller

